JSON文档模型设计
	误区
		不需要模型设计
		应该用一个超大文档来组合所有数据
		不支持关联或事务

设计原则
	性能
	开发易用

关系数据库			JSON文档模型
关联关系，主外键		内嵌数组，引用字段

 文档模型设计三步曲
 业务需求及逻辑模型			->逻辑导向	基础建模		->			集合、字段、基础形状
 技术需求读写比例、方式及数量	->技术导向	工况细化		->			引用及关联
 经验和学习					->模式导向	套用设计模式	->			最终模式

找到实体对象
明确关系 1-1，1-N，N-N

关系建模
	基本原则 
		1对1以内嵌为主。内嵌后文档不能大于16M
		一对多内嵌为主。用数组表示。内嵌后文档大小不能超过16M，数组长度太大（数万或更多），数组长度不确定持续增长
		不需要映射表，一般用内嵌数组表示

最频繁的数据查询模式
最常用的查询参数
最频繁的数据写入模式
读写操作的比例
数据量的大小

使用引用来避免性能瓶颈
使用冗余来优化访问性能

类似于关系型设计，使用id或者唯一键关联 使用$lookup来提供一次查询多表的能力（类似关联）Mongo3.2+
db.contacts.aggregate([{
	$lookup:{
		from: "groups",
		localField: "group_ids",
		foreignField: "group_id",
		as: "groups"
	}	
}]);

引用设计原则
内嵌后文档大小不能超过16M，数组长度太大（数万或更多），数组长度不确定持续增长
引用设计限制
除非必要，否则不用
MongoDB对使用引用的集合之间并无主外键检查
$lookup只支持left outer join
$lookup的关联目标（from）不能是分片表

套用设计模式
文档模型：无范式，无思维定式，充分发挥想象力
设计模式：实战过屡试不爽的设计技巧，快速应用
一个IOT场景的分桶设计模式，存储空间降低10倍，查询效率提升10倍

飞机飞行记录，每分钟记录一条
飞机飞行记录，每小时记录一条，每分钟的数据写到对应的元素中



分桶嵌套模式
场景		时序数据、物联网、智慧城市、智慧交通
痛点		数据点采集频繁、数据量太多
优点		利用文档内嵌数组，将一个时间段的数据聚合到一个文档里，大量减少文档数量，减少索引占用空间

好的设计模式可以显著的
提升数据读写的效率
降低资源的需求

更多设计模式
表现形式类	列转行、文档版本
数据访问类	子集、近似处理
组织结构类	预聚合、分桶



列转行
	电影在多个国家上映，日期不同。用多个字段标识不同国家上映日期
	可将其转为数组，{国家，上映日期}作为每条子数据。
	db.movies.creatIndex({"releases.country":1, "releases.date":1})

	场景 多国家、多语言属性
	痛点 文档中有很多类似字段，组合查询搜索，需要很多索引
	优点 转换为数组 一个索引解决所有查询问题

版本字段
	场景 任何有版本衍变的数据库
	痛点	 文档模型格式多，无法知道其合理性。升级的时候需要更新太多的文档
	优点 增加一个版本号字段，快速过滤掉不需要升级的文档，升级的时候对不同版本的文档做不同的处理

近似处理
	场景 网页计数、各种结果不需要准确的排名
	痛点 写入太频繁，消耗系统资源
	优点 间隔写入，每10次货100次。大量减少写入的需求

预聚合
	场景 准确排名、排行榜
	痛点 统计耗时较长、消耗资源多
	优点 在模型中直接增加统计字段，每次更新数据的时候更新统计值











